# instructor logic

1. run wrapped completion.create 
 - handle_response_model
 - function | tools = Model.openai_schema

which looks like
openai_schema = {
    "description":"Correctly extracted `UserDetail` with all the required parameters with correct types",
    "name":"UserDetail",
    "parameters":{
        "properties":{
            "age":{
                "title":"Age",
                "type":"integer"
            },
            "name":{
                "title":"Name",
                "type":"string"
            }
        },
        "required":[
            "age",
            "name"
        ],
        "type":"object"
    }
}

but with the new tools param it shoudd look like this
{
    "type": "function",
    "function": $openai_schame,
}

2. The OpenAISchema Class
- has the .openai_schema property that generates a dict that fits the `functions` parameter of an openai.completion.create() call

3. The wrapped openai.completion.create() function Jason created also forces openai to call this function by specifying the `function_call` param to the the `model.openai_schema.name` property

4. However after calling the wrapped completion method, Jason simply uses the arguments generated by openai's initial response as the input to his OpenAiSchema model validation response (which remember is a sub class of Pydantic's BaseModel)

